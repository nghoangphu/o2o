"use strict";

module.exports = tracer

var inherits = require("util").inherits
var EventEmitter = require("events").EventEmitter
var instrument = require("./instrument")
var statware = require("statware")

// One minute
var DEFAULT_INTERVAL = 60 * 1000
var MINIMUM_ARCHIVE_INTERVAL = 5000
var MAXIMUM_ARCHIVE_INTERVAL = 60000
var VERSION = require("./package.json").version

// Prevent flood attacks on proxy when using cluster
var FUDGE = Math.floor(5000 * Math.random())

function tracer(config) {
  if (require('strongloop-license')('agent:tracing')) {
    return new StrongTrace(config)
  } else {
    return null
  }
}

function StrongTrace(config) {
  if (!(this instanceof StrongTrace)) return new StrongTrace(config)
  EventEmitter.call(this)
  var key = config.accountKey || config.account_key
  if (key == null) {
    throw new Error("Missing required 'account_key'.")
  }
  this.accountKey = key
  this.archiveInterval = config.archiveInterval || config.archive_interval
  if (this.archiveInterval == null) {
    config.archive_interval = DEFAULT_INTERVAL
    this.archiveInterval = DEFAULT_INTERVAL
  }

  // Used to override the hostname in the trace packet
  this.traceId = config.traceId;

  this.config = config
  config.version = VERSION

  this.statware = statware().installSystemInfo().installProcessInfo()
  this.uploader = config.useHttp ? new require("./upload")(config) : null

  this.tracer = instrument(config)
  this.start()
}
inherits(StrongTrace, EventEmitter)

StrongTrace.prototype.start = function start() {
  if (this.interval != null) {
    // Already have a recurring send interval
    return
  }
  if (this.archiveInterval < MINIMUM_ARCHIVE_INTERVAL || this.archiveInterval > MAXIMUM_ARCHIVE_INTERVAL) {
    throw new Error("StrongTrace archive interval must be between " + MINIMUM_ARCHIVE_INTERVAL + " and " + MAXIMUM_ARCHIVE_INTERVAL)
  }
  // Send one out almost immediately
  setTimeout(this.send.bind(this), 250)
  this.interval = setInterval(this.send.bind(this), this.archiveInterval + FUDGE)
  this.unref()
}

StrongTrace.prototype.unref = function unref() {
  if (this.interval && this.interval.unref) {
    this.interval.unref()
  }
}

StrongTrace.prototype.stop = function stop() {
  clearInterval(this.interval)
}

StrongTrace.prototype.assemble = function assemble(callback) {
  this.tracer.tag("strongtrace.assemble")
  var waterfalls = this.tracer.reap()
  var packet = {
    metadata: {
      timestamp: Date.now(),
      type: "nodejs",
      version: VERSION,
      tracing_interval: this.archiveInterval,
      pid: process.pid,
      account_key: this.accountKey,
      config: this.tracer.config,
      stack_stats: this.tracer.aggregator.stackStats.getAll(),
      waterfall_stats: this.tracer.aggregator.waterfallStats.getAll(),
      stacks_collapsed: this.tracer.aggregator.stacksCollapsed,
      orphaned_links: this.tracer.aggregator.orphanedLinks
    },
    monitoring: {},
    functions: this.tracer.functions,
    waterfalls: waterfalls,
    transactions: this.tracer.transactionlog.reapSubset()
  }

  if (this.config.dump_stack) {
    packet.stack = this.tracer.stack
  }

  var self = this
  this.statware.getStats(function (stats) {
    var hostname = self.traceId ||
      stats.system_info.hostname.split('.',1)[0];
    stats.system_info.hostname = hostname
    packet.monitoring = stats
    callback(packet)
  })
}

StrongTrace.prototype.metrics = function metrics() {
  return this.statware.namespace("custom_stats")
}

StrongTrace.prototype.send = function send() {
  this.tracer.tag("strongtrace.send")
  var self = this
  this.assemble(function (packet) {
    if( self.uploader) {
      self.uploader.send(packet, function (status) {
        self.emit("send", status)
      })
    } else {
      var traceObject = {version: self.config.version, packet: packet}
      self.emit("trace:object", traceObject)
    }
  })
}
