"use strict";

module.exports = TraceAggregator

var BlockFactory = require("./lib/block")
var UniqueQueue = require("./lib/unique_queue")
var Waterfall = require("./lib/waterfall")
var AggregateWaterfall = require("./lib/aggregate_waterfall")
var Stats = require("stats-incremental")

function TraceAggregator(tracer) {
  this.tracer = tracer

  this.reset()

  // Stats
  this.stackStats = Stats()
  this.waterfallStats = Stats()
}

TraceAggregator.prototype.reset = function reset() {
  this.cache = []
  this.seen = []
  this.leaves = []
  this.targets = {}
  this.waterfalls = {}
  this.origins = {}
}


/*    Handling a single stack     */
// These need to be as fast as possible. They will be called every time
//   we think js is yielding to the event loop.

// Prep the stack for later aggregation
TraceAggregator.prototype.saveStack = function saveStack(stack) {
  this.stackStats.update(stack.length)
  var miniwf = []
  var outgoing = {}
  var outgoingTxs = {}
  var incomingTxs = {}
  var incoming = {}
  var tags = []
  var tZero = []
  var outgoingCount = 0
  var incomingCount = 0
  var isLeaf = false

  var blockName = ""

  var index = this.cache.length

  var enterCount = 0
  var exitCount = 0

  var repeatState = null

  var bf = new BlockFactory()

  var substack = []
  var i, j, scheduled, resumed
  var sortIndex = 0

  for (i = 0; i < stack.length; i++) {
    var record = stack[i]

    // ENTER
    if (record.type === "enter") {
      if (tZero.length === 0) {
        tZero = record.ts
        bf.setZero(record.ts)
      }
      record.order = i
      substack.push(record)

      if( stack[i + 1] &&
          stack[i + 1].id === record.id &&
          (stack[i + 1].type === 'enter' ||
            (stack[i +1].type === 'exit' && stack[i + 2] && stack[i + 2].id === record.id && stack[i + 2].type === 'enter' &&
            stack[i + 3] && stack[i+3].id === record.id))) {
        // (all ids match)
        // debounch naming for repeated leaf
        if( !stack[i-1] || ( stack[i-1].id != record.id ) || !stack[i-1].repeat) {
          //the stuff before us did not exist or was different
          //thus, we are the first of the repeating elements
          record.repeat = bf.fn(record.id, record.ts, record.ts, record.order)
          record.needToPush = true
          blockName += "<" + record.id
          enterCount++
        } else {
          record.repeat = stack[i-1].repeat || stack[i-2].repeat
        }
      } else if( stack[i-1] && stack[i -1].repeat && stack[i-1].id == record.id && stack[i-1].type == 'enter'){
        //we are the final element in the debounce
        record.repeat = stack[i-1].repeat
      } else if( (stack[i-1] && stack[i-2] && stack[i-1].id == record.id && stack[i-1].type == 'exit' && stack[i-2].id == record.id && stack[i-2].type == 'enter' && stack[i-2].repeat)){
        record.repeat = stack[i-2].repeat
      } else {
        blockName += "<" + record.id
        enterCount++
      }
    }

    // EXIT
    else if (record.type === "exit") {
      var enter = substack.pop()
      if (enter == null || enter.id !== record.id) {
        // TBD how are we going to track errors like this? Send to cx?
        // TBD how to raise these errors without infinite stack recursion?
        // console.log('enter, record', enter, record)
        // console.log("Concurix stack id mismatch")
        return
      }

      // dedupe sequential repeats of the same function by incrementing visits
      if (enter.repeat) {
        // to make matching easier, go ahead and remember our repeat block
        record.repeat = enter.repeat
        enter.repeat.endTs = record.ts
        if( enter.needToPush ){
          delete enter.repeat.needToPush
          miniwf.push(enter.repeat)
          blockName += ">"
          exitCount++
        } else {
          //vists starts at 1, so the case above handles that
          enter.repeat.visits++
        }
      }
      else {
        miniwf.push(bf.fn(record.id, enter.ts, record.ts, enter.order))
        blockName += ">"
        exitCount++
      }
    }

    else if (record.type === "schedule") {
      if (record.isTx) {
        outgoingTxs[record.id] = bf.wait(record.id, record.name, record.ts, null, record.fnId)
        this.origins[record.id] = index
      }
      else {
        outgoing[record.id] = bf.wait(record.id, record.name, record.ts, null, record.fnId)
      }
      outgoingCount++
      if (incoming[record.id]) {
        // links to self
        incomingCount--
        outgoingCount--
      }
    }
    else if (record.type === "resume") {
      incoming[record.id] = bf.wait(record.id, record.name, null, record.ts, record.fnId)
      if (record.isTx) {
        incomingTxs[record.id] = index
      }
      incomingCount++
      if (outgoing[record.id]) {
        // links to self
        incomingCount--
        outgoingCount--
      }
      this.targets[record.id] = index
    }
    else if (record.type === "tag") {
      tags.push(record.name)
    }
  }

  if (enterCount !== exitCount) {
    // TBD how to raise these errors without infinite stack recursion?
    // console.log("Concurix Stack Accounting Error: %s !=== %s", enterCount, exitCount)
    // The accounting got messed up somehow. We'll need to track down this issue,
    // but for now, just log it and throw data away.
    return
  }

  miniwf = miniwf.sort(function (a, b) {
    return a.order - b.order
  })

  // No links in/out = easy isolated "leaf"
  if (outgoingCount <= 0 && incomingCount <= 0) {
    isLeaf = true
  }
  // Incoming links, but they aren't transactions and no outgoing links = "leaf"
  if (incomingCount > 0 && outgoingCount <= 0 && Object.keys(incomingTxs).length === 0) {
    isLeaf = true
  }

  var workBlock = {
    idx: index,
    tZero: tZero,
    name: blockName,
    nodes: miniwf,
    outgoing: outgoing,
    outgoingTxs: outgoingTxs,
    incomingTxs: incomingTxs,
    incoming: incoming,
    tags: tags
  }
  this.cache.push(workBlock)
  this.seen.push(0)

  // if a transaction end, finish the transaction
  var txIds = Object.keys(incomingTxs)
  for (i = 0; i < txIds.length; i++) {
    this.navigateTransaction(txIds[i], index)
  }
  if (isLeaf) {
    // if a leaf, go ahead and throw it to aggregation
    this.finishTransactionThread([index])
  }
}

/*    Aggregation Logic     */
// These are called only periodically

TraceAggregator.prototype.navigateTransaction = function (id, destIndex) {
  var origin = this.origins[id]
  if (origin == null) {
    // oops this transaction got truncated.
    // Toss the pieces of this transaction to the garbage aggregator.
    // Sucks, but it's the best we can do for now.
    // TBD keep transactions for X aggregation windows?
    return
  }
  var startSeg = this.cache[origin]
  var complete = false
  var target = null
  var path = []
  var links = Object.keys(startSeg.outgoing)
  for (var i = 0; i < links.length; i++) {
    // follow non-transaction links first
    target = this.targets[links[i]]
    if (target == null) {
      continue
    }
    path = this.followThread([origin], target, links[i], id, {})
    if (path.length > 0) {
      // complete all the wait link segments

      // TBD track share count on segments?
      //     difficulty: how to update already agg'd ones?
      return this.finishTransactionThread(path, id)
    }
  }
  var txs = Object.keys(startSeg.outgoingTxs)
  for (var j = 0; j < txs.length; j++) {
    if (txs[j] === id) {
      continue
    }
    target = this.targets[txs[j]]
    if (target == null) {
      continue
    }
    path = this.followThread([origin], target, txs[j], id, {})
    if (path.length > 0) {
      // complete all the wait link segments

      // TBD track share count on segments?
      //     difficulty: how to update already agg'd ones?
      return this.finishTransactionThread(path, id)
    }
  }
  this.finishTransactionThread([origin, id, destIndex], id)
}

TraceAggregator.prototype.followThread = function (thread, segId, linkId, transactionId, seenCache) {
  seenCache[segId] = true
  var target = null
  var path = []
  var segment = this.cache[segId]
  if (segment == null) {
    // We got lost...?
    return []
  }
  // Is this segment the end of transactionId?
  if (segment.incomingTxs[transactionId] != null) {
    // this finishes the transaction!
    // stop recursing and retun it
    return thread.concat(linkId, segId)
  }
  // Try non-transaction links first
  var outgoing = Object.keys(segment.outgoing)
  for (var i = 0; i < outgoing.length; i++) {
    target = this.targets[outgoing[i]]
    if (target == null || seenCache[target]) {
      // Don't get stuck in a loop
      continue
    }
    path = this.followThread([], target, outgoing[i], transactionId, seenCache)
    if (path.length) {
      // unwind
      return thread.concat(linkId, segId, path)
    }
  }
  // Try transactions next
  var outgoingTxs = Object.keys(segment.outgoingTxs)
  for (var j = 0; j < outgoingTxs.length; j++) {
    target = this.targets[outgoingTxs[j]]
    if (target == null || seenCache[target]) {
      // Don't get stuck in a loop
      continue
    }
    path = this.followThread([], target, outgoingTxs[j], transactionId, seenCache)
    if (path.length) {
      // unwind
      return thread.concat(linkId, segId, path)
    }
  }
  // We didn't make it to transactionId; too bad so sad
  return []
}

TraceAggregator.prototype.finishTransactionThread = function (path, transactionId) {
  // finalize the stack
  var firstBlock = this.cache[path[0]]
  var waterfall = new Waterfall(firstBlock.tZero)

  var self = this
  var addLink = function (srcId, tgtId, linkId) {
    var srcSeg = self.cache[srcId]
    var src = (srcSeg.outgoing[linkId] != null) ? srcSeg.outgoing[linkId] : srcSeg.outgoingTxs[linkId]
    var tgt = self.cache[tgtId].incoming[linkId]
    if (src == null || tgt == null) {
      // TODO how to report these?
      return
    }
    waterfall.addLink(src, tgt)
  }

  var i = 0
  for (i = 0; i < path.length; i += 2) {
    // Add the segments
    waterfall.addSegment(this.cache[path[i]])
    this.seen[path[i]]++
  }
  for (i = 1; i < path.length; i += 2) {
    // Add the links
    if (path[i] === transactionId) {
      continue
    }
    addLink(path[i - 1], path[i + 1], path[i])
  }
  if (transactionId != null) {
    // manually finish transaction link segment
    addLink(path[0], path[path.length - 1], transactionId)
  }

  // send to aggregation
  this.aggregate(waterfall)
}

TraceAggregator.prototype.aggregate = function (waterfall) {
  var name = waterfall.blockNames.join("~")
  if (this.waterfalls[name] == null) {
    this.waterfalls[name] = new AggregateWaterfall(waterfall)
    this.waterfallStats.update(this.waterfalls[name].segments.length)
  }
  else {
    this.waterfalls[name].combine(waterfall)
  }
}

TraceAggregator.prototype.reap = function () {
  // Go through all the unseen segments and finish them up
  for (var i = 0; i < this.seen.length; i++) {
    if (this.seen[i] === 0) {
      this.finishTransactionThread([i])
    }
  }

  var wfArray = []
  var wfids = Object.keys(this.waterfalls)
  for (var j = 0; j < wfids.length; j++) {
    wfArray.push(this.waterfalls[wfids[j]])
  }
  this.reset()
  return wfArray
}
