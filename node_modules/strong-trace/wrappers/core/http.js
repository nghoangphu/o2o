"use strict";

module.exports = wrap
module.exports.wrapOutgoingMessage = wrapOutgoingMessage

function wrap(tracer, httpx) {
  var http_module = require(httpx)
  tracer.addCoreFile(httpx)

  // client
  var reqFnId = tracer.addFunction(httpx, "request")
  var request = http_module.request
  http_module.request = function (options, callback) {
    var traceme = tracer.enter(reqFnId)

    var id = tracer.getId()
    var linkName = httpx + ".request"
    tracer._schedule(id, linkName)

    var txId
    if (callback) {
      var cb = callback
      callback = function (res) {
        tracer._resume(id, linkName)
        res.once("end", function () {
          tracer.endTransaction(txId, res.statusCode)
        })
        return cb.call(this, res)
      }
    }
    var req = request.call(this, options, callback)

    var txName = "request" + " " + req.method + " " + httpx + "://" + req._headers.host + req.path

    txId = tracer.startTransaction(txName)

    // If a callback was passed this would be too late. If not, they either
    //   don't have a callback or may be adding a response listener
    if (!callback) {
      var addListener = req.addListener
      req.addListener = function (listener, fn) {
        if (listener === "response") {
          var wrapper = function wrapper(res) {
            tracer._resume(id, linkName)
            res.once("end", function () {
              tracer.endTransaction(txId, res.statusCode)
            })
            return fn.call(this, res)
          }
          addListener.call(this, listener, wrapper)
        }
        else {
          addListener.apply(this, arguments)
        }
      }
      req.on = req.addListener
    }


    if (traceme) {
      tracer.exit(reqFnId)
    }
    return req
  }
  // http.ClientRequest.prototype.end

  // server

  // TODO configuration option to disable transaction tracing?

  // wrap Server.prototype.addListener 'request'
  var addListener = http_module.Server.prototype.addListener
  var listenerId = tracer.addFunction(httpx, "Server.prototype.addListener")
  http_module.Server.prototype.addListener = function (listener, fn) {
    var traceme = tracer.enter(listenerId)
    if (listener === "request") {
      // NOTE: we *could* instrument this wrapper but it may already be
      //   instrumented because it actually wraps userland code.
      var wrapper = function wrapper(req, res) {
        // Generate a transaction id and tag the response object with it.

        // TBD do we need some sort of (optional/configurable?) url sanitizer?
        //   e.g. if someone is adding cache-defeating random strings this becomes useless
        res.__concurix_txId = tracer.startTransaction("serve" + " " + req.method + " " + req.url)
        return fn.call(this, req, res)
      }
      addListener.call(this, listener, wrapper)
    }
    else {
      // TBD clientError?
      addListener.apply(this, arguments)
    }
    if (traceme) {
      tracer.exit(listenerId)
    }
  }

  // TBD cancelled/timed-out requests?
  //   e.g. http.Server.prototype.setTimeout -- hard to wrap
  //   e.g. http.IncomingMessage.prototype.setTimeout

  http_module.Server.prototype.listen = tracer.wrapCoreLinker(httpx, "Server.prototype.listen", http_module.Server.prototype.listen)
  http_module.Server.prototype.close = tracer.wrapCoreLinker(httpx, "Server.prototype.close", http_module.Server.prototype.close)
}

function wrapOutgoingMessage(tracer) {
  var http = require("http")
  tracer.addCoreFile("http")
  var proxyEnd = http.OutgoingMessage.prototype.end
  var endId = tracer.addFunction("http", "OutgoingMessage.prototype.end")
  http.OutgoingMessage.prototype.end = function () {
    var traceme = tracer.enter(endId)
    tracer.endTransaction(this.__concurix_txId, this.statusCode)
    var rvalue = proxyEnd.apply(this, arguments)
    if (traceme) {
      tracer.exit(endId)
    }
    return rvalue
  }
}
