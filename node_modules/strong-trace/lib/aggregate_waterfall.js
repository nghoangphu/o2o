"use strict";

module.exports = AggregateWaterfall

function AggregateWaterfall(initial) {
  this.segments = initial.segments
  this.id = initial.blockNames.join("~")
  this.tags = merge([], initial.tags)
  this.instance_count = 1
}

AggregateWaterfall.prototype.combine = function combine(waterfall) {
  var i
  this.instance_count++

  if (this.segments.length !== waterfall.segments.length) {
    // TODO how to handle this correctly?
    // console.log("\nWATERFALL MISMATCH!")
    // console.log(this.id, waterfall.blockNames.join("~"))
    // console.log(this.segments, waterfall.segments)
  }

  // average segments
  for (i = 0; i < this.segments.length; i++) {
    var existing = this.segments[i]
    var newSeg = waterfall.segments[i]
    if (newSeg == null || existing.type !== newSeg.type) {
      // TODO how to handle this correctly
      //console.log("UH OH!!! type mismatch")
      // This usually happens when we see something with/witout transactions
      //   but is the same waterfall otherwise
      continue
    }
    if (existing.type === "fn" && existing.id !== newSeg.id) {
      // TODO how to handle this correctly
      // TBD Waits are likely to have different names -- standardize them?
      //console.log("UH OH!!! %s !== %s", existing.id, newSeg.id)
    }
    // TBD Could easily use stats-incremental here, but would generate lots more data
    existing.start = average(existing.start, newSeg.start, this.instance_count)
    existing.end = average(existing.end, newSeg.end, this.instance_count)
    existing.visits = average(existing.visits, newSeg.visits, this.instance_count)
  }

  // merge tags
  this.tags = merge(this.tags, waterfall.tags)
}

// Incremental mean
function average(mean, observation, n) {
  return mean + (observation - mean) / n
}

// For now choosing not to use an ES6 set or polyfill
function merge(target, newArray) {
  var i
  for (i = 0; i < newArray.length; i++) {
    if (target.indexOf(newArray[i]) < 0) {
      target.push(newArray[i])
    }
  }
  return target
}
