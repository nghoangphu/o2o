// Copyright IBM Corp. 2015. All Rights Reserved.
// Node module: strong-agent
// US Government Users Restricted Rights - Use, duplication or disclosure
// restricted by GSA ADP Schedule Contract with IBM Corp.

'use strict';

var agent = require('../agent');
var debug = require('../debug')('probes:redis');
var proxy = require('../proxy');
var samples = require('../samples');
var counts = require('../counts');
var tiers = require('../tiers');
var topFunctions = require('../top-functions');
var graphHelper = require('../graph-helper');

module.exports = function(redis) {
  var proto = redis.RedisClient.prototype;
  if (typeof proto.internal_send_command === 'function') {
    proxy.before(proto, 'internal_send_command', before);  // redis@>=2.6
  } else {
    proxy.before(proto, 'send_command', compat);  // redis@<2.6
  }
  return redis;
};

function compat(recv, args) {
  var cmd = { command: args[0], args: args[1] };
  before(recv, [cmd]);
}

function before(recv, args) {
  if (agent.paused) return;

  var cmd = args[0];
  if (!cmd) return;

  var command = cmd.command;
  var input = cmd.args;

  if (!Array.isArray(input)) return;

  var timer = samples.timer('Redis', command);
  var query = command +
              (typeof input[0] === 'string' ? ' "' + input[0] + '"' : '');
  var graphNode = graphHelper.startNode('Redis', query, agent);

  counts.sample('redis');
  debug('command: %s', command);

  function handle(obj, args, extra) {
    timer.end();

    debug('%s callback', command);
    topFunctions.add('redisCalls', query, timer.ms);
    graphHelper.updateTimes(graphNode, timer);

    if (extra) {
      debug('%s extra: ', extra);
      extra.redis = extra.redis || 0;
      extra.redis += timer.ms;
      tiers.sample(extra.closed ? 'redis_out' : 'redis_in', timer);
    } else {
      tiers.sample('redis_in', timer);
    }
  }

  function getCommandAndKey(command, input){
    while(Array.isArray(input)){
      if (typeof input[0] === 'string') {
        var keyValue = '"' + input[0] + '"';
        if (typeof input[1] === 'string') keyValue += ' "' + input[1] + '"';
        return command + " " + keyValue;
      }
      input = input[0];
      continue;
    }
    return command;
  }

  function strongTraceTransaction(query, callback){
    var linkName = "Redis " + query;
    return agent.transactionLink(linkName, callback);
  }

  var des = Object.getOwnPropertyDescriptor(cmd, 'callback');
  if (des && des.configurable) {
    var callback = des.value;
    if (typeof callback !== 'function') callback = function() {};
    var interceptor = proxy.oncall(callback, handle);
    proxy.install(cmd, 'callback', des, interceptor);
  } else {
    // Support send_command(com, [arg, cb]) and send_command(com, [arg], cb)
    var callbackIndex = args.length - 1;
    if (typeof args[callbackIndex] === 'function') {
      args[callbackIndex] = strongTraceTransaction(
        getCommandAndKey(command, input), args[callbackIndex]);
      proxy.callback(args, callbackIndex, handle);
    } else {
      // Hack to support optional functions by adding noop function when
      // blank
      callbackIndex = input.length - 1;
      if (typeof input[callbackIndex] !== 'function') {
        input.push(function() {});
        callbackIndex += 1;
      }
      input[callbackIndex] =
          strongTraceTransaction(getCommandAndKey(command, input),
                                 input[callbackIndex]);
      proxy.callback(input, callbackIndex, handle);
    }
  }

  if (graphNode) agent.currentNode = graphNode.prevNode;
}
